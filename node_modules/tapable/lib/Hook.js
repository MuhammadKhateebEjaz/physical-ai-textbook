/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const util = require("util");

const deprecateContext = util.deprecate(
	() => {},
	"Hook.context is deprecated and will be removed"
);

function CALL_DELEGATE(...args) {
	this.call = this._createCall("sync");
	return this.call(...args);
}

function CALL_ASYNC_DELEGATE(...args) {
	this.callAsync = this._createCall("async");
	return this.callAsync(...args);
}

function PROMISE_DELEGATE(...args) {
	this.promise = this._createCall("promise");
	return this.promise(...args);
}

class Hook {
	constructor(args = [], name = undefined) {
		this._args = args;
		this.name = name;
		this.taps = [];
		this.interceptors = [];
		this._call = CALL_DELEGATE;
		this.call = CALL_DELEGATE;
		this._callAsync = CALL_ASYNC_DELEGATE;
		this.callAsync = CALL_ASYNC_DELEGATE;
		this._promise = PROMISE_DELEGATE;
		this.promise = PROMISE_DELEGATE;
		this._x = undefined;

		// eslint-disable-next-line no-self-assign
		this.compile = this.compile;
		// eslint-disable-next-line no-self-assign
		this.tap = this.tap;
		// eslint-disable-next-line no-self-assign
		this.tapAsync = this.tapAsync;
		// eslint-disable-next-line no-self-assign
		this.tapPromise = this.tapPromise;
	}

	compile(_options) {
		throw new Error("Abstract: should be overridden");
	}

	_createCall(type) {
		return this.compile({
			taps: this.taps,
			interceptors: this.interceptors,
			args: this._args,
			type
		});
	}

	_tap(type, options, fn) {
		if (typeof options === "string") {
			options = {
				name: options.trim()
			};
		} else if (typeof options !== "object" || options === null) {
			throw new Error("Invalid tap options");
		}
		if (typeof options.name !== "string" || options.name === "") {
			throw new Error("Missing name for tap");
		}
		if (typeof options.context !== "undefined") {
			deprecateContext();
		}
		options = Object.assign({ type, fn }, options);
		options = this._runRegisterInterceptors(options);
		this._insert(options);
	}

	tap(options